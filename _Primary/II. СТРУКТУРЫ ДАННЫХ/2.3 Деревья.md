### Дерево - структура данных, эмулирующая древовидную структуру в виде набора связанных узлов (связный граф без циклов)

Виды деревьев:
==Binary tree== (BT), двоичное дерево **O(n)** - значения хранятся в рандомной последовательности
	1. нода хранит ключ:значение
	2. самая верхняя нода - корень (root)
	3. ноды без детей - лист (leaf)
	4. нода может иметь максимум 2 детей

==Binary search tree== (BST), двоичное дерево поиска **O(n)** - значения добавляются по правилам
	1. если ребенок меньше предка то insert налево
	2. delete с 0 или 1 ребенком - ребенок / null
	3. delete с 2 детьми - левая подветка (minLeft) < ребенок < правая подветка (maxRight)
	4. симметричный обход - самый левый->родитель->правый (вывод по возрастанию)
	5. обратный обход - левый ребенок->правый ребенок->родитель (memory safe deletion)
	6. прямой обход - родитель->левый ребенок->правый ребенок (memory copy)

==AVL-tree== (Adelson-Velsky & Landis), АВЛ-дерево **O(logn)** - сбалансированное по высоте двоичное дерево поиска
	1. у каждой ноды +член - ее высота
	2. разница высоты каждой дочки <=|1|
	3. leaf node height 0
	4. null node height -1
	5. после операции проверка на перегрузку дерева (влево-2 или право+2)
	6. для балансировки - поворот влево/вправо
	7. если перегруз влево - чек баланс левого ребенка == 1 -> левый-правый поворот
	8. чек баланс левого ребенка == -1 -> просто правый поворот
	9. если перегруз право - чек баланс правого ребенка == -1 -> правый-левый поворот
	10. при удалении рекурсивно в стеке балансировать каждый раз

==Red-black tree== (RBT), красно-черное дерево **O(logn)** - самобалансирующееся двоичное дерево поиска
	1. нода без детей - null
	2. root и null - ЧЕРНЫЕ
	3. у КРАСНОЙ ноды оба ребенка ЧЕРНЫЕ
	4. ЧЕРНАЯ высота - кол-во ЧЕРНЫХ узлов на пути от root к null (root не учитывается)
	5. у каждой ноды +член - ссылка на родителя, вместо рекурсии цикл
	6. вставка новой ноды КРАСНАЯ